<!DOCTYPE html>
<html lang="ko" xml:lang="ko">
<head>
<meta charset="utf-8">
<script src="../pb_inc.js"></script>
<script>include.meta();</script>
<!-- ======================== CSS / JS ======================== -->
<script>include.styles();</script>
<script>include.scripts();</script>
<!--// ======================== CSS / JS ======================== -->
<script>include.title();</script>
</head>  

<body>
<div class="_pb-guide">
	<!-- ========== 공통 헤더 ========== -->
	<script>include.header();</script>
	<!--// ========== 공통 헤더 ========== -->

	<!-- ========== 컨텐츠 영역 ========== -->
	<main class="_pb-container">
		<div class="_pb-contents">
			<div class="_pb-side-bar">
				<script>include.sidebar('Tips');</script>
			</div>
			
			<article class="_pb-article">
				<div class="_pb-page-tit">
					<h2>Function</h2>
					<!-- <p class="_pb-page-desc">가이드 설명</p> -->
				</div>

				<section class="_pb-section">
					<h3 class="_pb-section-tit">인자 호출 방식</h3>
					<!-- <p class="_pb-section-desc"></p> -->
					<div class="_pb-component">
						<!-- ========== Component ========== -->
						// 프로토타입 포폴 jokerAction(), gpt(myUI.javascript -> 20250827_스크롤페이지_2 ) 정리해서 넣어야 함
						<!--// ========== Component ========== -->	
					</div><!--// _pb-component -->
					<script></script>
				</section><!--// _pb-section  -->

				<section class="_pb-section">
					<h3 class="_pb-section-tit">변수/함수, 이벤트리스너</h3>
					<!-- <p class="_pb-section-desc"></p> -->
					<div class="_pb-component">
						<!-- ========== Component ========== -->
						// dev-proto_ver.0.1.2_코드리뷰
						// 프로토타입 eventOn() 주석 참조<br>
						// 이벤트 실행과 등록, 함수를 담은 변수 실행, 함수 실행 ()<br>
						// ()가 없으면 즉시실행이므로 이벤트핸들러 안에 넣으면 안된다.!
						// 넣어야 한다면 화살표 함수로 감싸거나 function() {...} 안에 넣으면 됨
						<!--// ========== Component ========== -->	
					</div><!--// _pb-component -->
					<script></script>
				</section><!--// _pb-section  -->

				<section class="_pb-section">
					<h3 class="_pb-section-tit">일반 함수와 화살표 함수</h3>
					<p class="_pb-section-desc">this의 바인딩 방식이 서로 다르다는 점 유의</p>
					<!-- <h4 class="_pb-component-tit">Component sub title</h4> -->
					<p class="_pb-component-desc">
						- this가 필요하면 일반 함수 (function) 쓰기 (DOM 이벤트, 객체 메서드, 클래스 등)<br>
						- 간단한 로직/콜백/return만 있으면 화살표 함수 (map, filter, sort, Promise 등)<br>
						- arguments 써야 하면 무조건 일반 함수
					</p>
					<div class="_pb-board inactive">
						<button type="button" class="_pb-toggle-btn"><i class="icon icon-chevron-down bg-black"></i></button>
                        <table>
                            <caption>목록</caption>
                            <colgroup>
								<col>
                                <col style="width: 30%">
								<col style="width: 50%">
                            </colgroup>
							<thead>
								<tr>
									<th scope="col"></th>
									<th scope="col">일반 함수</th>
									<th scope="col">화살표 함수</th>
								</tr>
							</thead>
                            <tbody>
                                <tr>
									<th scope="row">this</th>
                                    <td>자기 실행 컨텍스트에서 this를 바인딩함<br> (function() {} 쓰면 그때 정해짐</td>
									<td>
										상위 스코프의 this를 그대로 씀. this = window<br>이벤트 대상을 찾으려면 e.currentTarget 로 찾는다. 
<pre>
element.addEventListener('click', (e) => { 
  <code class="text-primary">e.currentTarget</code>.classList.add('active');  // 올바른 방법
});
</pre>
<div class="_pb-pre-guide">
	e.currentTarget은 이벤트가 걸려 있는 그 엘리먼트 자신을 가리킴 (e.target은 실제로 클릭된 하위 요소)<br>
	즉, e.currentTarget은 항상 안전하고 정확하게 현재 그 엘리먼트를 가리킨다.
</div>
<pre>
element.addEventListener('click', (e) => { 
  <code class="text-primary">element</code>.classList.add('active'); // 잘못된 방법!!
});
</pre>
<div class="_pb-pre-guide">
	element 변수 직접 참조하는 게 위험한 이유?<br>
	클로저 상황에서 예전 el을 기억해서 잘못된 걸 참조할 수도 있고..<br>
	그 el 자체가 이미 다른 DOM으로 교체되거나 없어졌을 수도 있고..<br>
	반복문 안에서 el을 참조하면 마지막 값만 남아있기도 하고 (let 안 쓰면 특히)
</div>
									</td>
                                </tr>
								<tr>
									<th scope="row">DOM 이벤트 핸들러</th>
                                    <td>this가 이벤트 대상 요소가 됨</td>
									<td>요소 안 됨</td>
                                </tr>
								<tr>
									<th scope="row">메서드 정의용</th>
                                    <td>클래스나 객체 메서드용으로 안정적</td>
									<td>피해야 함 (this 꼬임)</td>
                                </tr>
								<tr>
									<th scope="row">constructor (생성자)</th>
                                    <td>new 키워드로 인스턴스 생성 가능</td>
									<td>사용 불가</td>
                                </tr>
								<tr>
									<th scope="row">arguments 객체</th>
                                    <td>있음 (arguments[0] 등)</td>
									<td>없음</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
				</section><!--// _pb-section  -->

				<section class="_pb-section">
					<h3 class="_pb-section-tit">고차함수와 클로저</h3>
					<!-- <div class="_pb-section-tips">
						<button type="button" class="_pb-tips-btn"><i class="icon-css-info-bold"></i></button>
						<ul class="_pb-info-list">
							<li class="_pb-info-item"></li>
						</ul>
					</div> -->
					<h4 class="_pb-component-tit">고차함수(Higher-Order Function)</h4>
					<p class="_pb-component-desc">
						함수를 인자로 받거나, 함수를 반환하는 함수. 즉, 함수를 다루는 함수. (ex: forEach, map, filter, setTimeout...) <br>

					</p>
					<div class="_pb-component _pb-component--border inactive">
						<button type="button" class="_pb-toggle-btn"><i class="icon icon-chevron-down bg-black"></i></button>
						<!-- ========== Component ========== -->
<pre>
ex1) 인자를 함수로 받는 경우
function repeat(n, callback) { // repeat는 고차 함수
	for (let i = 0; i < n; i++) {
		callback(i);
	}
}

repeat(3, console.log); // console.log는 콜백 함수로 전달된 일반 함수
// 0  → // 1  → // 2
</pre>
<pre>
ex2) 함수를 반환하는 경우
function multiplier(factor) { // multiplier()는 고차 함수
	return function(num) { // 호출하면 factor가 캡처된 내부 함수가 리턴됨
		return num * factor;
	}
}

const double = multiplier(2);
console.log(double(5)); // 10 
</pre>
						<div class="_pb-pre-guide">
							ex2) 이 내부 함수는 자기만의 설정을 기억함 → 이걸 클로저(closure) 라고 한다.
						</div>
						<!--// ========== Component ========== -->	
					</div><!--// _pb-component -->

					<h4 class="_pb-component-tit">클로저(Closure)</h4>
					<p class="_pb-component-desc">
						함수가 선언될 때의 주변 환경(변수들) 을 기억하는 것을 클로져 현상이라고 하며,
						그것을 '변수를 캡쳐했다(captured)' 라고 표현한다.
					</p>
					<div class="_pb-component _pb-component--border inactive">
						<button type="button" class="_pb-toggle-btn"><i class="icon icon-chevron-down bg-black"></i></button>
						<!-- ========== Component ========== -->
<pre>
function outer() {
	const message = "안녕 Closure!";

	return function inner() {
		console.log(message);
	}
}
const fn = outer(); // outer() 실행 → inner 함수 리턴됨
fn();
</pre>
						<div class="_pb-pre-guide">
							outer() 실행되면 message는 일반적으로 스코프 밖에서 사라져야 하지만, inner() 함수가 그 message를 "기억" 하고 있음. <br>
							이렇게 기억하고 있는 함수 자체를 클로져라고 한다. inner가 outer의 지역변수를 캡처(capture) 해서 참조 유지하고 있는 것.<br>
							함수가 실행되는 시점 이후에도 외부 변수에 접근 가능하다.
						</div>
						<!--// ========== Component ========== -->	
					</div><!--// _pb-component -->
					
					<h4 class="_pb-component-tit">Related</h4>
					<!-- <p class="_pb-section-desc"></p> -->
					<div class="_pb-board _pb-board-small">
                        <table>
                            <caption>목록</caption>
                            <colgroup>
                                <col span="3">
                            </colgroup>
                            <tbody>
								<tr>
                                    <th scope="row">Carousel</th>
									<td>carouselSlide함수(동작 관련)를 외부로 분리하면서, 내부 상태 접근을 위해 사용</td>
                                    <td>
										<a href="../components/carousel.html" class="btn-text btn-text-sm text-primary">
											<strong>관련 문서</strong>
											<i class="icon icon-chevron-right"></i>
										</a>
									</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
				</section><!--// _pb-section  -->

				<section class="_pb-section">
					<h3 class="_pb-section-tit">Try/Catch, AbortController</h3>
					<!-- <p class="_pb-section-desc"></p> -->
					<h4 class="_pb-component-tit">Component sub title</h4>
					<div class="_pb-component">
						<!-- ========== Component ========== -->
						//
						<!--// ========== Component ========== -->	
					</div><!--// _pb-component -->
					<script></script>
				</section><!--// _pb-section  -->
			</article>
		</div>
	</main>
	<!--// ========== 컨텐츠 영역 ========== -->
</div><!--// _pb-guide -->

<script>include.bottom();</script>

</body>
</html>
